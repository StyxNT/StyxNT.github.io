{"meta":{"title":"StyxNT","subtitle":"","description":"","author":"Styx","url":"https://styxnt.vercel.app","root":"/"},"pages":[{"title":"我的朋友们","date":"2021-02-22T12:13:28.716Z","updated":"2021-02-22T12:13:28.716Z","comments":true,"path":"friends/index.html","permalink":"https://styxnt.vercel.app/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"","date":"2021-02-22T12:11:24.760Z","updated":"2021-02-22T12:11:24.760Z","comments":true,"path":"404.html","permalink":"https://styxnt.vercel.app/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2021-02-22T12:13:14.518Z","updated":"2021-02-22T12:13:14.518Z","comments":true,"path":"categories/index.html","permalink":"https://styxnt.vercel.app/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-03-18T05:25:15.315Z","updated":"2021-03-18T05:25:15.315Z","comments":true,"path":"about/index.html","permalink":"https://styxnt.vercel.app/about/index.html","excerpt":"","text":"本站基于Hexo构建，使用Volantis作为主题，Twikoo作为评论系统 本站默认替换了右键菜单，若要使用原生的右键菜单，可以使用ctrl+右击 非常感谢Github Vercel jsdelivr以及腾讯云的强力支持！"},{"title":"","date":"2021-02-22T12:13:43.089Z","updated":"2021-02-22T12:13:43.089Z","comments":true,"path":"mylist/index.html","permalink":"https://styxnt.vercel.app/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-02-22T12:13:59.152Z","updated":"2021-02-22T12:13:59.152Z","comments":true,"path":"tags/index.html","permalink":"https://styxnt.vercel.app/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"一个因为Axios异步请求导致的vue组件参数问题","slug":"一个因为Axios异步请求导致的vue组件参数问题","date":"2021-07-12T09:09:04.000Z","updated":"2021-07-12T09:11:56.420Z","comments":true,"path":"2021/07/12/一个因为Axios异步请求导致的vue组件参数问题/","link":"","permalink":"https://styxnt.vercel.app/2021/07/12/%E4%B8%80%E4%B8%AA%E5%9B%A0%E4%B8%BAAxios%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E5%AF%BC%E8%87%B4%E7%9A%84vue%E7%BB%84%E4%BB%B6%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98/","excerpt":"在进行Vue开发时遇到了一个因为axios异步请求导致的问题。","text":"在进行Vue开发时遇到了一个因为axios异步请求导致的问题。 问题描述问题如下：在Vue组件中需要用到data中的user数据来在页面上显示用户的名字&#123;&#123;user.name&#125;&#125; 但是在进入页面时，浏览器控制台报错： 从报错的结果来看，似乎是data中的user数据未被初始化 data中的代码如下: 12345data()&#123; return&#123; user:this.user=JSON.parse(window.sessionStorage.getItem(&#x27;user&#x27;)) &#125;&#125;, 理论上来说，user数据应该会在数据初始化时从sessionStorage中取出，但处于某些原因，user数据并没有被正确的初始化。 解决过程我首先尝试了使用Vue的钩子函数在Vue实例的不同生命周期来进行user数据的初始化，但还是失败了 1234mounted()&#123; console.log(&quot;进入Home组件初始化&quot;+window.sessionStorage.getItem(&#x27;user&#x27;)); this.user=this.user=JSON.parse(window.sessionStorage.getItem(&#x27;user&#x27;)); &#125;, 从报错的结果来看，问题并不在于user数据的初始化，而在于user数据根被没有被存储进sessionStorage 于是，我又调整方向，在保存user信息的代码中进行了一些尝试 这段代码的主要作用是配置了VueRouter的路由守卫，使得它在每次路由跳转的时候都会检查是否有token和用户信息，如果没有就存入用户信息 1234567891011121314151617181920router.beforeEach((to, from, next) =&gt; &#123; console.log(&quot;进入路由守卫&quot;); if(window.sessionStorage.getItem(&#x27;token&#x27;))&#123; //生成菜单 initMenu(router,store); console.log(&quot;生成菜单&quot;); //保存用户信息到sessionStorage // console.log(window.sessionStorage.getItem(&#x27;user&#x27;)) if(window.sessionStorage.getItem(&#x27;user&#x27;)===null)&#123; console.log(&quot;获取user信息&quot;); getRequest(&#x27;/admin/info&#x27;).then(response=&gt;&#123; console.log(&quot;写入user信息&quot;); if(response)&#123; window.sessionStorage.setItem(&#x27;user&#x27;,JSON.stringify(response)); &#125; &#125;) &#125; &#125; next();&#125;) 运行后的结果如下: 从结果来看，很显然路由守卫中获取用户信息的请求的执行被放在了跳转后页面的生成之后，而跳转的页面就是要用到这些信息的页面，因此导致了user信息获取失败 解决方法造成这一问题的原因是axios默认是异步执行的，因此我们只需让路由守卫同步调用axios方法即可，这样就能保证其必须在获取完用户信息后再进行页面的跳转 修改后代码如下： 1234567891011121314151617181920router.beforeEach(async (to, from, next) =&gt; &#123; console.log(&quot;进入路由守卫&quot;); if(window.sessionStorage.getItem(&#x27;token&#x27;))&#123; //生成菜单 initMenu(router,store); console.log(&quot;生成菜单&quot;); //保存用户信息到sessionStorage // console.log(window.sessionStorage.getItem(&#x27;user&#x27;)) if(window.sessionStorage.getItem(&#x27;user&#x27;)===null)&#123; console.log(&quot;获取user信息&quot;); await getRequest(&#x27;/admin/info&#x27;).then(response=&gt;&#123; console.log(&quot;写入user信息&quot;); if(response)&#123; window.sessionStorage.setItem(&#x27;user&#x27;,JSON.stringify(response)); &#125; &#125;) &#125; &#125; next();&#125;) 我们可以通过添加async 和 await 来实现 getRequest方法的同步阻塞运行 修改后运行结果如下： 可以看到，通过await关键字，我们使得原先的异步请求变为了同步请求，程序必须等待getRequest方法运行完毕，user数据保存好之后再运行接下来的代码","categories":[{"name":"-前端","slug":"前端","permalink":"https://styxnt.vercel.app/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"-前端 -Vue -Axios","slug":"前端-Vue-Axios","permalink":"https://styxnt.vercel.app/tags/%E5%89%8D%E7%AB%AF-Vue-Axios/"}]},{"title":"SpringMVC笔记","slug":"SpringMVC笔记","date":"2021-03-18T05:50:07.000Z","updated":"2021-03-18T06:03:12.853Z","comments":true,"path":"2021/03/18/SpringMVC笔记/","link":"","permalink":"https://styxnt.vercel.app/2021/03/18/SpringMVC%E7%AC%94%E8%AE%B0/","excerpt":"初学SpringMVC时的笔记，在博客上备份一下","text":"初学SpringMVC时的笔记，在博客上备份一下 HelloSpringMVC 使用配置文件实现一个简单的SpringMVC程序，实际开发中并不会使用这种方式 1. 配置web.xml1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt;&lt;!-- 配置前端控制器DispatchServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;!-- 配置DispatchServlet要绑定的配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;!-- 设置启动级别(1:跟随服务器启动)--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt;&lt;!-- 所有请求都会被SpringMVC拦截--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 这里本质上是配置了一个前端控制器DispatchServlet，用来处理前端的请求 2. 配置springmvc-servlet.xml配置文件12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!-- 处理器映射器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;&lt;!-- 处理器适配器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;&lt;!-- 视图解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt;&lt;!-- 前缀--&gt; &lt;property name=&quot;prefix&quot; value=&quot;/jsp/&quot;/&gt;&lt;!-- 后缀--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;/hello&quot; class=&quot;com.nt.controller.Hello&quot;/&gt;&lt;/beans&gt; 这个配置文件实际上就是Spring的配置文件，其中手动注册了SpringMVC处理请求需要的类 这里配置的前缀和后缀实际上是进行了浏览器访问时路径名的拼接，其中前缀的/jsp/代表前端页面的保存位置是web目录下的jsp文件夹，后缀的.jsp则表示前端页面文件的格式为jsp 这样做的好处便是，原先我如果要访问jsp文件夹下的页面，需要在浏览器输入完整的路径http://localhost:8080/jsp/hello，而现在我只需要输入http://localhost:8080/hello便可访问 这里我在Tomcat的配置中将应用程序上下文配置成了”/“而非默认的”/包名”，所以在上文的完整路径访问地址中没有出现包名 3. Controller类123456789101112131415161718package com.nt.controller;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class Hello implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; ModelAndView mv=new ModelAndView(); String result=&quot;Hello,SpringMVC&quot;; mv.addObject(&quot;msg&quot;,result); mv.setViewName(&quot;test&quot;); return mv; &#125;&#125; 需要注意的是，这里的test指的是准备跳转前往的test.jsp文件，因为在springmvc-servlet.xml已经进行了相关的前缀和后缀配置，所以只需要填入文件名即可，填写完整路径会使得拼接后的路径名出错 在实际访问时，我们并不会使用/test来进行访问，这是因为我们在springmvc-servlet.xml中注册这个类时，配置的id名为/hello所以在访问时，也是用/hello 使用注解实现SpringMVC开发1. 配置web.xml1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt;&lt;!-- 配置前端控制器DispatchServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;!-- 配置DispatchServlet要绑定的配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;!-- 设置启动级别(1:跟随服务器启动)--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt;&lt;!-- 所有请求都会被SpringMVC拦截--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 2. 配置springmvc-servlet.xml配置文件12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;&lt;!--开启自动包扫描--&gt; &lt;context:component-scan base-package=&quot;com.nt.controller&quot;/&gt;&lt;!-- 阻止springmvc拦截静态资源--&gt; &lt;mvc:default-servlet-handler/&gt;&lt;!-- 开启注解驱动支持--&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 视图解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀--&gt; &lt;property name=&quot;prefix&quot; value=&quot;/jsp/&quot;/&gt; &lt;!-- 后缀--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 3. Controller类1234567891011121314151617package com.nt.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(&quot;/h&quot;)public class Hello&#123; @RequestMapping(&quot;/hello&quot;) public String hello(Model model) &#123; model.addAttribute(&quot;msg&quot;,&quot;Hello&quot;); return &quot;test&quot;;//这里return的参数实际上就是要跳转的jsp页面的名字，这里就是test.jsp // 然后会被视图解析器处理 &#125;&#125; 需要注意的是，在类名上的@RequestMapping是可写可不写的，如果写了，则访问地址就是http://localhost:8080/h/hello 如果不写则是http://localhost:8080/hello RESTFul风格 Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 传统的网页传参往往是通过http://localhost:8080/test?id=1这样的形式实现，而RESTFul风格则是http://localhost:8080/test/1这样的形式 使用路径变量的好处： 使路径变得更加简洁； 获得参数更加方便，框架会自动进行类型转换。 通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。 SpringMvc实现RESTFul风格1234567891011121314151617package com.nt.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class RestFulController &#123; @RequestMapping(&quot;/add/&#123;a&#125;/&#123;b&#125;&quot;) public String add(@PathVariable int a, @PathVariable int b, Model model) &#123; model.addAttribute(&quot;msg&quot;,a+b); return &quot;test&quot;; &#125;&#125; 在访问路径上，我们需要添加模板变量 在方法的参数列表中，我们需要添加注释@PathVariable RequestMappingSpring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。 所有的地址栏请求默认都会是 HTTP GET 类型的。 方法级别的注解变体有如下几个：组合注解 12345@GetMapping@PostMapping@PutMapping@DeleteMapping@PatchMapping @GetMapping 是一个组合注解，平时使用的会比较多！ 它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。 转发与重定向SpringMvc默认的跳转方式是转发（地址栏不会变化），如果需要实现重定向，需要在return语句中加入redirect: 例如 return &quot;redirect:test&quot;; 获取前端传入参数&amp;&amp;乱码问题&amp;&amp;Model相关https://mp.weixin.qq.com/s?__biz=Mzg2NTAzMTExNg==&amp;mid=2247483998&amp;idx=1&amp;sn=97c417a2c1484d694c761a2ad27f217d&amp;scene=19#wechat_redirect","categories":[{"name":"Java","slug":"Java","permalink":"https://styxnt.vercel.app/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://styxnt.vercel.app/tags/Java/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://styxnt.vercel.app/tags/SpringMVC/"}]},{"title":"Spring笔记","slug":"Spring笔记","date":"2021-03-18T05:49:59.000Z","updated":"2021-03-18T06:05:11.643Z","comments":true,"path":"2021/03/18/Spring笔记/","link":"","permalink":"https://styxnt.vercel.app/2021/03/18/Spring%E7%AC%94%E8%AE%B0/","excerpt":"初学Spring时的笔记，在博客上做一下备份","text":"初学Spring时的笔记，在博客上做一下备份 IOC容器在xml文件中配置对象1. 无惨构造函数创建对象123&lt;bean id=&quot;hello&quot; class=&quot;com.nt.pojo.hello&quot; &gt; &lt;property name=&quot;str&quot; value=&quot;hello spring&quot;/&gt; &lt;/bean&gt; 其中hello相当于new对象时的对象名，class=&quot;&quot;等价于需要实例化的类 12345678910111213&#96;&#96;&#96;value&#96;&#96;&#96;或者&#96;&#96;&#96;ref&#96;&#96;&#96;就是我想要传入的值或对象的引用#### 2. 构造函数创建对象1. 下表赋值2. 类型赋值3. 参数名赋值（常用）&#96;&#96;&#96;xml&lt;bean id&#x3D;&quot;hello&quot; class&#x3D;&quot;com.nt.pojo.hello&quot; &gt;&lt;!-- &lt;property name&#x3D;&quot;str&quot; value&#x3D;&quot;hello spring&quot;&#x2F;&gt;--&gt; &lt;constructor-arg name&#x3D;&quot;name&quot; value&#x3D;&quot;tttest&quot;&#x2F;&gt;&lt;&#x2F;bean&gt; 3. 在xml中配置bean时value 和ref的区别ref==reference:引用 value：值 所以value是给name对应的变量赋值，而ref则是传入一个对象的引用 用ref属性，spring容器会在引用后进行验证，验证当前xml中是否存在引用的bean 用value属性，spring会在容器启动，实例化bean时进行验证。 相当于用value会导致错误延迟发现。此外value不仅有类似引用功能，它还有基本的构造函数赋值功能。 4. xml文件中的配置属性 :实例化对象 id:对象的唯一标识 class:实例化的类 name:对象的名字（相较于id的别名，可以取多个name，通过 “,” “；” 或者 空格 分割，例如：name=”name1,name2 name3；name4”） :为对象取别名 :导入其他.xml配置文件 5. 实例化IOC容器1234567891011public class helloTest &#123; @Test public void test() &#123; ApplicationContext context=new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);//获取xml文件（可以获取多个） hello _hello= (hello) context.getBean(&quot;hello&quot;);//从容器中获得对象 System.out.println(_hello.toString()); &#125;&#125; 6. 总结 IOC容器中的对象在配置文件加载的时候全都会进行实例化，不论是否被使用 DI依赖注入1. 构造方法注入 *参考上文* 2. set方法注入​ 3. 其它方式注入 p命名空间注入 c命名空间注入 bean作用域 Scope Description singleton （单例） (默认)将每个 Spring IoC 容器的单个 bean 定义范围限定为单个对象实例。 prototype 将单个 bean 定义的作用域限定为任意数量的对象实例。 request 将单个 bean 定义的范围限定为单个 HTTP 请求的生命周期。也就是说，每个 HTTP 请求都有一个在单个 bean 定义后面创建的 bean 实例。仅在可感知网络的 Spring ApplicationContext中有效。 session 将单个 bean 定义的范围限定为 HTTP Session的生命周期。仅在可感知网络的 Spring ApplicationContext上下文中有效。 application 将单个 bean 定义的范围限定为ServletContext的生命周期。仅在可感知网络的 Spring ApplicationContext上下文中有效。 websocket 将单个 bean 定义的范围限定为WebSocket的生命周期。仅在可感知网络的 Spring ApplicationContext上下文中有效。 使用注解进行装配1.xml文件准备工作在xml文件中配置启用注解装配： 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; 在idea中，添加context:annotation-config/即可自动完成配置 2.使用@Resource注解时的注意事项@Resource注解源于JavaEE，因此需要事先对项目安装JavaEE库 1import javax.annotation.Resource; 3. @Autowired和@Resource的区别https://blog.csdn.net/weixin_40423597/article/details/80643990 使用@Component完成Bean的装配使用@Component进行Bean的装配可以免去配置xml文件 1.首先需要在xml文件中添加以下语句：1&lt;context:component-scan base-package=&quot;com.nt.*&quot;/&gt; 使用该语句可以自动扫描com.nt下的所有bean，这样就无需再手动往xml文件中添加bean了 2.使用注解@Component(“job”)注意！如果使用@Component时未指定ID（name），则默认为类名的首字母小写（例如WorkingServer-&gt;workingServer）该注解等价于 123&lt;bean id=&quot;job&quot; class=&quot;com.nt.pojo.AnnotationTestJob&quot;&gt; &lt;/bean&gt; 3.属性注入12@Value(&quot;Teacher&quot;)private String jobName; 使用@Value进行属性注入时，可以不用提供setter方法 2、如果提供了set方法，在set方法上添加@Value(“值”); 12345678910@Component(&quot;user&quot;)public class User &#123; public String name; @Value(&quot;123&quot;) public void setName(String name) &#123; this.name = name; &#125;&#125; 4.衍生注解@Component三个衍生注解 为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。 @Controller：web层 @Service：service层 @Repository：dao层 5.作用域@Scope singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。 prototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收 123456@Controller(&quot;user&quot;)@Scope(&quot;prototype&quot;)public class User &#123; @Value(&quot;123&quot;) public String name;&#125; AOP在maven中添加依赖 123456789101112131415&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.6&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- 使用注解配置AOP需要添加以下依赖--&gt;&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjrt --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.9.6&lt;/version&gt;&lt;/dependency&gt; 配置xml环境 12345678910xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; 使用xml配置实现AOP（Spring的API接口）1.编写AOP类前置式： 1234567@Componentpublic class BeforeLog implements MethodBeforeAdvice &#123; @Override public void before(Method method, Object[] objects, Object o) throws Throwable &#123; System.out.println(o.getClass().getName()+&quot;的&quot;+method.getName()+&quot;被执行了&quot;); &#125;&#125; 后置式： 1234567public class AfterLog implements AfterReturningAdvice &#123; @Override public void afterReturning(Object returnValue, Method method, Object[] objects, Object target) throws Throwable &#123; System.out.println(&quot;执行了&quot;+method.getName()+&quot;方法，返回了&quot;+returnValue); &#125;&#125; TODO： 2.在xml文件中配置AOP12345678&lt;!-- AOP配置--&gt; &lt;aop:config&gt;&lt;!-- 切入点--&gt; &lt;aop:pointcut id=&quot;workingServerPoint&quot; expression=&quot;execution(* com.nt.AOPTest.WorkingServer.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;beforeLog&quot; pointcut-ref=&quot;workingServerPoint&quot;/&gt; &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;workingServerPoint&quot;/&gt; &lt;/aop:config&gt; 自定义类实现AOP（切面）1.编写自定义的切面类1234567891011package com.nt.AOPTest;import org.springframework.stereotype.Component;@Component(&quot;after&quot;)public class CustomClassAOPAfter &#123; public void after() &#123; System.out.println(&quot;after&quot;); &#125;&#125; 2.配置xml文件1234567891011&lt;!--自定义类实现AOP--&gt; &lt;aop:config&gt;&lt;!-- 自定义切面 ref为要引用的类--&gt; &lt;aop:aspect ref=&quot;after&quot;&gt;&lt;!-- 切入点--&gt; &lt;aop:pointcut id=&quot;customPointCut&quot; expression=&quot;execution(* com.nt.AOPTest.CustomClassAOPWorkingServer.* (..))&quot;/&gt;&lt;!-- 通知（advice）--&gt; &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;customPointCut&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 注解实现AOP1.开启xml支持1&lt;aop:aspectj-autoproxy/&gt; 2.切面类的编写1234567891011121314151617181920212223242526package com.nt.aoptest;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.springframework.stereotype.Component;//配置切面@Component@Aspectpublic class AnnotationAopWorkingAspect &#123; //切入点 @Before(&quot;execution(* com.nt.aoptest.AnnotationAopWorkingServer.* (..))&quot;) public void before() &#123; System.out.println(&quot;before.....&quot;); &#125; @After(&quot;execution(* com.nt.aoptest.AnnotationAopWorkingServer.*(..))&quot;) public void after() &#123; System.out.println(&quot;after.....&quot;); &#125;&#125; SpringJdbcxml文件中对应bean的配置123456789101112131415161718&lt;!-- Spring jdbc配置--&gt;&lt;!-- 配置数据源DataSource--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;&lt;!-- 数据库驱动--&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test?serverTimezone=UTC&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;pswd&quot;/&gt; &lt;/bean&gt;&lt;!-- 配置jdbc模板--&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;&lt;!-- 默认必须使用数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt;&lt;!-- 配置注入类--&gt; &lt;bean id=&quot;springJdbcBookDao&quot; class=&quot;com.nt.springjdbctest.SpringJdbcBookDao&quot;&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt; &lt;/bean&gt;","categories":[{"name":"Java","slug":"Java","permalink":"https://styxnt.vercel.app/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://styxnt.vercel.app/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://styxnt.vercel.app/tags/Spring/"}]},{"title":"Mybatis笔记","slug":"Mybatis笔记","date":"2021-03-18T05:48:44.000Z","updated":"2021-03-18T06:01:05.475Z","comments":true,"path":"2021/03/18/Mybatis笔记/","link":"","permalink":"https://styxnt.vercel.app/2021/03/18/Mybatis%E7%AC%94%E8%AE%B0/","excerpt":"这是初学Mybatis时所记的笔记，其中还有很多没有完善的地方，所以上传到博客上仅作为备份","text":"这是初学Mybatis时所记的笔记，其中还有很多没有完善的地方，所以上传到博客上仅作为备份 0. Mybatis配置模板核心配置文件： 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;!--这里因为把db.properties放在了resources资源文件夹之下了，所以可以直接填写文件名，否则需要填写路径名或者添加资源路径--&gt; &lt;properties resource=&quot;db.properties&quot;&gt; &lt;/properties&gt; &lt;settings&gt;&lt;!-- &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;--&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.nt.beans&quot;/&gt; &lt;/typeAliases&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;!-- 注册Mapper.xml文件--&gt; &lt;mappers&gt; &lt;/mappers&gt;&lt;/configuration&gt; mapper： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;&quot;&gt;&lt;/mapper&gt; 1. 配置Mybatis核心配置文件src/main/resources/mybatis-config.xml 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 2. 构建 SqlSessionFactory1234567891011private static SqlSessionFactory sqlSessionFactory; static &#123; String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = null; try &#123; inputStream = Resources.getResourceAsStream(resource); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; 3. 获取SqlSession实例1234public static SqlSession getSqlSession()&#123; return sqlSessionFactory.openSession();&#125; 注意：每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 4. 使用SQLSessionFactory获取SQLSession的完整代码1234567891011121314151617181920212223242526272829303132package com.nt.mybatistest;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class GetSqlSessionUtils &#123; //构建 SqlSessionFactory private static SqlSessionFactory sqlSessionFactory; static &#123; String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = null; try &#123; inputStream = Resources.getResourceAsStream(resource); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; //从 SqlSessionFactory 中获取 SqlSession public static SqlSession getSqlSession() &#123; return sqlSessionFactory.openSession(); &#125;&#125; 5. 一个简单的Mybatis实例5.1 编写DAO接口使用mybatis时，我们不再需要手动写接口的实现对象，我们只需编写DAO的接口，然后通过编写mapper.xml配置文件，Mybatis就会自动帮我们实现这个接口的对象 123456789package com.nt.mybatistest;import com.nt.beans.User;import java.util.List;public interface UserDao &#123; List&lt;User&gt; getUserList();&#125; 5.2 编写mapper.xml12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--相当于实现了UserDao接口的方法--&gt;&lt;!--namespace绑定一个对应的DAO/mapper接口--&gt;&lt;mapper namespace=&quot;com.nt.mybatistest.UserDao&quot;&gt;&lt;!--id对应的就是UserDao接口中的方法名(getUserList())--&gt; &lt;select id=&quot;getUserList&quot; resultType=&quot;com.nt.beans.User&quot;&gt; select * from test.userinf &lt;/select&gt;&lt;/mapper&gt; 5.3 在Mybatis核心配置文件中注册mapper.xml1234&lt;!-- 注册Mapper.xml文件--&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/nt/mybatistest/UserInfMapper.xml&quot;/&gt; &lt;/mappers&gt; 5.4 在maven的配置文件pom.xml中添加mapper.xml的资源路径123456789101112&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 5.5 编写测试类123456789101112131415161718192021222324252627282930package MybatisTests;import com.nt.beans.User;import com.nt.mybatistest.GetSqlSessionUtils;import com.nt.mybatistest.UserDao;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import java.util.List;public class UserDaoTest &#123; @Test public void test() &#123; //获得sqlSession对象 SqlSession sqlSession=GetSqlSessionUtils.getSqlSession();// 方式一执行SQL UserDao userDao=sqlSession.getMapper(UserDao.class);//生成一个UserDao对象 List&lt;User&gt; userList=userDao.getUserList();//调用userDao对象中的方法 for (User user : userList) &#123; System.out.println(user); &#125;// 关闭session sqlSession.close(); &#125;&#125; 6. mapper配置文件标签namespace：需要实例化的DAO接口的包名 id:DAO接口中的对应方法 resultType：返回值类型（默认全限定名） parameterType：需要注入到id对应方法中的参数类型 7. CURD7.1 根据id查询数据UserDao接口： 1234public interface UserDao &#123; List&lt;User&gt; getUserList(); User getUserById(int id);&#125; mapper： 123&lt;select id=&quot;getUserById&quot; resultType=&quot;com.nt.beans.User&quot; parameterType=&quot;int&quot;&gt; select * from test.userinf where id=#&#123;id&#125;&lt;/select&gt; 测试方法： 1234567891011121314 @Test public void getUserByIdTest() &#123; int id=1; SqlSession sqlSession=GetSqlSessionUtils.getSqlSession(); UserDao userDao=sqlSession.getMapper(UserDao.class); User user=userDao.getUserById(id); System.out.println(user); sqlSession.close(); &#125;&#125; 7.2 增加数据 注意:增删改需要提交事务commit 1int addUser(User user); 1234&lt;!-- 对象中的属性，可以直接填入使用--&gt; &lt;insert id=&quot;addUser&quot; parameterType=&quot;com.nt.beans.User&quot;&gt; insert into test.userinf(id, name, pswd) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;pswd&#125;) &lt;/insert&gt; 12345678910111213141516@Testpublic void addUserTest()&#123; User user=new User(); user.setId(6); user.setName(&quot;大范围&quot;); user.setPswd(&quot;sda56as&quot;); SqlSession sqlSession=GetSqlSessionUtils.getSqlSession(); UserDao userDao=sqlSession.getMapper(UserDao.class); userDao.addUser(user); //提交事务 sqlSession.commit(); sqlSession.close();&#125; 7.3 修改数据1int updateUser(User user); 123&lt;update id=&quot;updateUser&quot; parameterType=&quot;com.nt.beans.User&quot;&gt; update test.userinf set name=#&#123;name&#125;,pswd=#&#123;pswd&#125; where id=#&#123;id&#125;&lt;/update&gt; 123456789101112131415@Testpublic void updateUserTest()&#123; User user=new User(); user.setId(6); user.setName(&quot;updateName&quot;); user.setPswd(&quot;11111&quot;); SqlSession sqlSession=GetSqlSessionUtils.getSqlSession(); UserDao userDao=sqlSession.getMapper(UserDao.class); userDao.updateUser(user); sqlSession.commit(); sqlSession.close();&#125; 7.4 删除数据1int deleteUserById(int id); 123&lt;delete id=&quot;deleteUserById&quot; parameterType=&quot;int&quot;&gt; delete from test.userinf where id=#&#123;id&#125;&lt;/delete&gt; 1234567891011@Testpublic void deleteUserByIdTest()&#123; int id=6; SqlSession sqlSession=GetSqlSessionUtils.getSqlSession(); UserDao userDao=sqlSession.getMapper(UserDao.class); userDao.deleteUserById(id); sqlSession.commit(); sqlSession.close();&#125; 7.5 模糊查询 在传入的参数中使用通配符% 在sql语句中使用通配符% 1like &quot;%&quot;#&#123;value&#125;&quot;%&quot; 需要注意的是 这里的%必须要以双引号引起来，单引号会导致查询结果为空 7.6 SQL语句的多参数传入 7.6.1 索引方式 注意 1：在老版本中，索引使用数字表示，如#{0}，#{1}，但在新版本中，索引的表示方式改为了#{arg0}或#{param1} 注意 2：#{arg}索引下标从0开始，而#{param}则从1开始 123&lt;select id=&quot;getUserLimited&quot; resultType=&quot;user&quot;&gt; select * from test.userinf limit #&#123;arg0&#125;,#&#123;arg1&#125;&lt;/select&gt; 参数的索引顺序与DAO结构中对应方法的参数顺序相同 7.6.2 使用Map实现多参数传入 1List&lt;User&gt; getUserLimitedByMap(HashMap&lt;String, Integer&gt; paramMap); 123&lt;select id=&quot;getUserLimitedByMap&quot; parameterType=&quot;map&quot; resultType=&quot;user&quot;&gt; select * from test.userinf limit #&#123;startIndex&#125;,#&#123;amount&#125;&lt;/select&gt; #{}中的参数就是map中的键(key)名，传入的值就是键(key)所对应的值(value) 7.6.3 使用注解实现多参数传入1List&lt;User&gt; getUserLimitedByAnnotation(@Param(&quot;startIndex&quot;)int startIndex,@Param(&quot;amount&quot;) int amount); 1234&lt;!-- 注解方式实现的多参数传入--&gt;&lt;select id=&quot;getUserLimitedByAnnotation&quot; resultType=&quot;user&quot;&gt; select * from test.userinf limit #&#123;startIndex&#125;,#&#123;amount&#125;&lt;/select&gt; 8. 配置文件8.1 environment配置 多环境（default=”#{环境名}”选择环境） 事务管理（默认JDBC） 连接池（默认pooled） 8.2 properties8.2.1 我们可以使用单独的properties文件来保存连接数据库所需的信息（驱动、数据库地址、账户和密码）例如 db.properties： 1234driver=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC&amp;useSSL=falseusername=rootpassword=pswd 8.2.2 在mybatis-config.xml文件中引入db.properties文件1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;!--这里因为把db.properties放在了resources资源文件夹之下了，所以可以直接填写文件名，否则需要填写路径名或者添加资源路径--&gt; &lt;properties resource=&quot;db.properties&quot;&gt; &lt;/properties&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;!-- 注册Mapper.xml文件--&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/nt/mybatistest/UserInfMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 此外，在properties标签之内也可以添加属性配置 8.3 类型别名（typeAliases）类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。例如： 12345678&lt;typeAliases&gt; &lt;typeAlias alias=&quot;Author&quot; type=&quot;domain.blog.Author&quot;/&gt; &lt;typeAlias alias=&quot;Blog&quot; type=&quot;domain.blog.Blog&quot;/&gt; &lt;typeAlias alias=&quot;Comment&quot; type=&quot;domain.blog.Comment&quot;/&gt; &lt;typeAlias alias=&quot;Post&quot; type=&quot;domain.blog.Post&quot;/&gt; &lt;typeAlias alias=&quot;Section&quot; type=&quot;domain.blog.Section&quot;/&gt; &lt;typeAlias alias=&quot;Tag&quot; type=&quot;domain.blog.Tag&quot;/&gt;&lt;/typeAliases&gt; 当这样配置时，Blog 可以用在任何使用 domain.blog.Blog 的地方。 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如： 123&lt;typeAliases&gt; &lt;package name=&quot;domain.blog&quot;/&gt;&lt;/typeAliases&gt; 每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 domain.blog.Author 的别名为 author；若有注解，则别名为其注解值。见下面的例子： 1234@Alias(&quot;author&quot;)public class Author &#123; ...&#125; 下面是一些为常见的 Java 类型内建的类型别名。它们都是不区分大小写的，注意，为了应对原始类型的命名重复，采取了特殊的命名风格。 别名 映射的类型 _byte byte _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal object Object map Map hashmap HashMap list List arraylist ArrayList collection Collection iterator Iterator 9. resultMap结果集映射 resultMap 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC ResultSets 数据提取代码中解放出来，并在一些情形下允许你进行一些 JDBC 不支持的操作。实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份 resultMap 能够代替实现同等功能的数千行代码。ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。 在默认情况下，bean中的属性名应该与数据表中的字段名对应。如果不对应，则返回的数据无法被正确注入，结果为null。 但是，我们可以使用resultMap进行结果集映射，将数据表中的字段和bean中的属性名对应起来。 9.1 首先我们新建一个测试用的Bean和方法这个bean中的属性名和数据表中的字段名完全不对应 123private int rid;private String rname;private String rpassword; 1ResultMapUserBeanTest getRuserById(int id); 在默认情况下使用这个bean接收数据库返回的值，会全部为null 9.2在mapper.xml中配置resultMap的映射123456&lt;!--结果集映射的配置--&gt; &lt;resultMap id=&quot;ruser&quot; type=&quot;Ruser&quot;&gt; &lt;result property=&quot;rid&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;rname&quot; column=&quot;name&quot;/&gt; &lt;result property=&quot;rpassword&quot; column=&quot;pswd&quot;/&gt; &lt;/resultMap&gt; id 为所配置映射的id type 为所配置bean的名字（别名/全限定名） property 为需要配置的bean中的属性名 column 为和属性映射的字段名 9.3 在mapper.xml中编写sql语句1234&lt;!-- resultMap测试用例--&gt; &lt;select id=&quot;getRuserById&quot; parameterType=&quot;int&quot; resultMap=&quot;ruser&quot;&gt; select * from test.userinf where id=#&#123;id&#125; &lt;/select&gt; 这里需要注意的是，原先的 resultType 在这里变为了 resultMap ，其属性为之前配置的映射的id 10. 日志工厂Mybatis开启日志功能需要在核心配置文件中开启相关设置 logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING 123&lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;&lt;/settings&gt; STDOUT_LOGGING：mybatis标准日志输出，配置就可生效 10.1 使用Log4j进行日志输出10.1.1 导入依赖123456&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 10.1.2 配置Log4j配置文件log4j.properties123456789101112131415161718192021222324#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码log4j.rootLogger=DEBUG,console,file#控制台输出的相关设置log4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target = System.outlog4j.appender.console.Threshold=DEBUGlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n#文件输出的相关设置log4j.appender.file = org.apache.log4j.RollingFileAppenderlog4j.appender.file.File=./log/Spring-Demo.loglog4j.appender.file.MaxFileSize=10mblog4j.appender.file.Threshold=DEBUGlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd HH:mm:ss&#125;][%c]%m%n#日志输出级别log4j.logger.org.mybatis=DEBUGlog4j.logger.java.sql=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.ResultSet=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG 10.1.3 在类中配置log4j在需要使用log4j的类中添加以下代码 参数为所在类的 类名.class 1static Logger logger=Logger.getLogger(UserDaoTest.class); 10.1.4 在需要进行日志输出的方法中调用logger对象的方法1234567@Testpublic void log4jTest()&#123; logger.info(&quot;info:进入了log4jTest方法&quot;); logger.debug(&quot;debug:进入了log4jTest方法&quot;); logger.error(&quot;error:进入了log4jTest方法&quot;);&#125; 10.1.5 在Mybatis的核心配置文件中开启Log4j123&lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;&lt;/settings&gt; 11.使用注解开发在mybatis中，只有一些简单的SQL语句适合使用注解，大部分情况下更加推荐xml文件进行配置 11.1 使用注解实现数据查询12@Select(&quot;select * from test.userinf&quot;)List&lt;User&gt; getUserByAnnotation(); 12. mybatis中$和# ＃&#123;&#125;将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：order by #{id}，如果传入的值是111,那么解析成sql时的值为order by “111”, 如果传入的值是id，则解析成的sql为order by “id”。 $&#123;&#125;将传入的数据直接显示生成在sql中。如：order by ${id}，如果传入的值是111,那么解析成sql时的值为order by 111, 如果传入的值是id，则解析成的sql为order by id。 #方式能够很大程度防止sql注入。 $方式无法防止Sql注入。 $方式一般用于传入数据库对象，例如传入表名. 一般能用#的就别用$. #在DBMS中处理，本质是pstm的? $在处理动态SQL阶段处理，本质是字符串的替换 13. 事务在默认情况下，当涉及到修改数据表的操作时，需要手动提交事务使修改生效 1sqlSession.commit(); 但是，我们也可以将事务设置为自动提交 1234public static SqlSession getSqlSession()&#123; return sqlSessionFactory.openSession(true);&#125; 在通过sqlSessionFactory获取sqlSession时，我们可以填入参数true开启事务的自动提交 14. mapper maven打包相关在默认情况下，maven在进行打包的时候，不会把除了resources文件夹之外的配置类文件进行打包。也就是说，如果我们把mapper文件放在非resources文件夹下（如接口同文件），则必须手动配置maven扫描配置文件。 配置如下： 12345678910111213&lt;!--添加资源路径--&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 如果我们直接把配置文件放在resources之下，则无需配置也可进行打包。此时，打包后的mapper配置文件会放在classes目录下，而非和接口同文件夹下。 如果希望打包后的配置文件和接口文件在同一文件夹下，这可以在resources目录下新建一个接口所在包的全路径 例如： src/main/resources/com/nt/mybatistest/UserDao.xml 此外还需注意的是，mapper配置文件放在resources根目录下和其他目录下时，在mybatis核心配置文件夹下注册mapper的方式也略有不同。 1234&lt;!-- 配置文件在非resources根目录下--&gt; &lt;mapper resource=&quot;com/nt/mybatistest/StudentMapper.xml&quot;/&gt;&lt;!-- 配置文件在resources根目录下--&gt; &lt;mapper resource=&quot;TeacherMapper.xml&quot;/&gt; 15.复杂查询15.1 多对一情况（多个学生对应同一个老师）15.1.1 按照查询嵌套处理（子查询）123private int id;private String name;private Teacher teacher; Student类中有Teacher类，在数据库中，Student和Teacher各有一个表，在Student表中有tid指向Teacher中对应的字段 我们要做的就是使用嵌套查询，用tid在Teacher表中找到对应的字段存入Teacher类，再将Teacher类注入Student类 12345public interface StudentMapper &#123; public List&lt;Student&gt; getAllStudent(); public List&lt;Teacher&gt; getAllTeacher();&#125; 在Student类中，getAllStudent()为主查询，getAllTeacher()则会被嵌套调用 1234567891011&lt;resultMap id=&quot;studentTeacher&quot; type=&quot;Student&quot;&gt; &lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;Teacher&quot; select=&quot;getAllTeacher&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getAllStudent&quot; resultMap=&quot;studentTeacher&quot;&gt; select * from test.student&lt;/select&gt;&lt;select id=&quot;getAllTeacher&quot; resultType=&quot;Teacher&quot;&gt; select * from test.teacher where id=#&#123;tid&#125;&lt;/select&gt; 在进行复杂的多表查询时，我们需要使用resultMap来进行查询， TODO 15.1.2 按照结果嵌套处理（连表查询）123456789101112&lt;resultMap id=&quot;allStudent&quot; type=&quot;Student&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;association property=&quot;teacher&quot; javaType=&quot;com.nt.beans.Teacher&quot;&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;getAllStudent2&quot; resultMap=&quot;allStudent&quot;&gt; select s.id as sid, s.name as sname, t.name as tname from test.student as s,test.teacher as t where s.tid=t.id&lt;/select&gt; 15.2 一对多情况（一个老师对应多个情况）TODO……….. 16. 动态SQL17. 查询结果的数据库字段与实体类属性名的匹配问题不区分大小写 不区分下划线 ，即goodsID可以与goods_id匹配","categories":[{"name":"Java","slug":"Java","permalink":"https://styxnt.vercel.app/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://styxnt.vercel.app/tags/Java/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://styxnt.vercel.app/tags/Mybatis/"},{"name":"MySQL","slug":"MySQL","permalink":"https://styxnt.vercel.app/tags/MySQL/"}]},{"title":"java分割并提取字符串中的所有单词、数字和符号","slug":"java分割并提取字符串中的所有单词、数字和符号","date":"2021-03-17T14:22:38.000Z","updated":"2021-03-17T14:41:58.583Z","comments":true,"path":"2021/03/17/java分割并提取字符串中的所有单词、数字和符号/","link":"","permalink":"https://styxnt.vercel.app/2021/03/17/java%E5%88%86%E5%89%B2%E5%B9%B6%E6%8F%90%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E3%80%81%E6%95%B0%E5%AD%97%E5%92%8C%E7%AC%A6%E5%8F%B7/","excerpt":"简单记录一种在java中分割并提取字符串中的所有单词、数字和符号的方法","text":"简单记录一种在java中分割并提取字符串中的所有单词、数字和符号的方法 今天在写代码的时候遇到了需要将字符串中的所有单词、数字和符号都提取出来的问题。一番搜索后找到了合适的解决方法，特此记录一下。 123List&lt;String&gt; strings= Arrays.stream(s.split(&quot;((?&lt;=[\\\\s\\\\p&#123;Punct&#125;])|(?=[\\\\s\\\\p&#123;Punct&#125;]))&quot;)) .filter(ss -&gt; !ss.trim().isEmpty()) .collect(Collectors.toList()); 其中s就是待处理的字符串。 以上代码出处http://ask.sov5.cn/q/NfDGfQJBQy","categories":[{"name":"Java","slug":"Java","permalink":"https://styxnt.vercel.app/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://styxnt.vercel.app/tags/Java/"},{"name":"字符串","slug":"字符串","permalink":"https://styxnt.vercel.app/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"SpringBoot集成Mybatis","slug":"SpringBoot集成Mybatis","date":"2021-03-16T11:09:38.000Z","updated":"2021-03-17T14:43:08.411Z","comments":true,"path":"2021/03/16/SpringBoot集成Mybatis/","link":"","permalink":"https://styxnt.vercel.app/2021/03/16/SpringBoot%E9%9B%86%E6%88%90Mybatis/","excerpt":"简单记录一下SpringBoot整合Mybatis的方法","text":"简单记录一下SpringBoot整合Mybatis的方法 添加maven依赖12345678910111213 &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.23&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt;&lt;/dependency&gt; 编写SpringBoot的配置文件123456789spring: datasource: username: password: url: jdbc:mysql://localhost:3306/springbootexp?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai driver-class-name: com.mysql.cj.jdbc.Drivermybatis: mapper-locations: classpath:mapper/*Mapper.xml type-aliases-package: com.exp.demo.pojo mapper-locations字段为mapper文件位置，这里对应的位置是resources目录下的mapper文件夹 type-aliases-package字段为指定的包下的类取别名 编写接口123456@Mapperpublic interface UserMapper &#123; List&lt;User&gt; getAllUser(); int addUser(User user);&#125; 注意要在接口类的上面添加注解@Mapper来注册mapper 当然，你也可以选择在SpringBoot启动类之上添加@MapperScan(“包名”)注解来扫描指定的包注册mapper 123456789@SpringBootApplication@MapperScan(&quot;com.exp.demo.dao&quot;)public class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://styxnt.vercel.app/categories/Java/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://styxnt.vercel.app/tags/SpringBoot/"},{"name":"Java","slug":"Java","permalink":"https://styxnt.vercel.app/tags/Java/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://styxnt.vercel.app/tags/Mybatis/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-02-19T05:40:50.994Z","updated":"2021-02-20T09:05:54.312Z","comments":true,"path":"2021/02/19/hello-world/","link":"","permalink":"https://styxnt.vercel.app/2021/02/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"-前端","slug":"前端","permalink":"https://styxnt.vercel.app/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Java","slug":"Java","permalink":"https://styxnt.vercel.app/categories/Java/"}],"tags":[{"name":"-前端 -Vue -Axios","slug":"前端-Vue-Axios","permalink":"https://styxnt.vercel.app/tags/%E5%89%8D%E7%AB%AF-Vue-Axios/"},{"name":"Java","slug":"Java","permalink":"https://styxnt.vercel.app/tags/Java/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://styxnt.vercel.app/tags/SpringMVC/"},{"name":"Spring","slug":"Spring","permalink":"https://styxnt.vercel.app/tags/Spring/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://styxnt.vercel.app/tags/Mybatis/"},{"name":"MySQL","slug":"MySQL","permalink":"https://styxnt.vercel.app/tags/MySQL/"},{"name":"字符串","slug":"字符串","permalink":"https://styxnt.vercel.app/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://styxnt.vercel.app/tags/SpringBoot/"}]}